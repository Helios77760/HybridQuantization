package plugins.dbrasseur.hybridquantization;

import icy.image.IcyBufferedImage;
import icy.image.IcyBufferedImageUtil;
import icy.sequence.Sequence;
import icy.type.DataType;
import icy.type.collection.array.Array1DUtil;
import icy.util.Random;
import plugins.adufour.ezplug.*;

import java.util.Arrays;

/**
 * Implementation of "HYBRID COLOR QUANTIZATION ALGORITHM INCORPORATING A HUMAN VISUAL PERCEPTION MODEL" by Schaefer and Nolle
 * @author Dylan Brasseur
 * @version 1.0
 *
 */
public class HybridQuantization extends EzPlug implements EzStoppable{

    public static long      perfTime;

	private EzVarSequence	EzinputSeq;				//Image Sequence
	private EzVarInteger	EznbOfColors;			//Number of colors to be used
	private EzVarBoolean    EzUniformization;       //Uniform fake palette from the individual palettes
	
	//General optimization parameters
	private EzVarInteger	EzpopulationSize;		//Population size (not supported yet)
	private EzVarInteger	Ezimax;					//Max number of iterations
	private EzVarFloat		Ezdelta;				//Penalty constant
	private EzVarEnum		EzDeltaE;				//DeltaE Type
	private EzVarFloat		EzConvDelay;			//Convergence delay
	private EzVarFloat		EzConvSpread;			//Convergence spread

	//Temperature
	private EzVarFloat		EzT0;					//Initial temperature
	private EzVarInteger	EziTc;					//Number of iterations per temperature
	private EzVarFloat		Ezalpha;				//Cooling coefficient
	
	//Step size parameters
	private EzVarFloat		Ezs0;					//Initial Max Step Width
	private EzVarFloat		Ezbeta;					//Adaptation constant

	//S-CIELAB Visual Settings
	private EzVarInteger    Ezdpi;                  //Dots per inch of the monitor
	private EzVarFloat      EzViewingDistance;      //Viewing distance in cm
	private EzVarEnum       EzWhitePoint;           //Whitepoint

    private boolean         stopFlag=false;
	
	
	@Override
	public void clean() {
		// TODO Auto-generated by Icy4Eclipse
	}

	@Override
	protected void execute() {
        stopFlag=false;
		quantization(false, EzinputSeq.getValue(), EznbOfColors.getValue(), EzpopulationSize.getValue(), Ezimax.getValue(), Ezdelta.getValue(), EzConvDelay.getValue(), EzConvSpread.getValue(),ImageManipulation.deltaETypes.CIE76, EzT0.getValue(), EziTc.getValue(), Ezalpha.getValue(), Ezs0.getValue(), Ezbeta.getValue(), Ezdpi.getValue(), EzViewingDistance.getValue(), (ScielabProcessor.Whitepoint) EzWhitePoint.getValue());
	}

	private void quantization(Boolean uniform, Sequence seq, Integer nbOfColors, Integer population, Integer imax, Float delta,Float convDelay, Float convSpread, ImageManipulation.deltaETypes deltaEType, Float T0, Integer iTc, Float alpha, Float s0, Float beta, Integer dpi, Float viewingDistance, ScielabProcessor.Whitepoint whitepoint) {
	    long start = System.currentTimeMillis();
	    setStageName("Initialisation...");
	    IcyBufferedImage im = IcyBufferedImageUtil.convertToType(seq.getFirstImage(), DataType.FLOAT,true);
	    ImageManipulation imageProcessor= new ImageManipulation(deltaEType);
	    SWASA swasa = new SWASA(population, imax, iTc, delta, convDelay,convSpread,T0, alpha, s0, beta, this);
		float[] inlineRGBImage = makeinline(im.getDataXYCAsFloat());
		perfTime = System.currentTimeMillis();
        setStageName("Initialisation de SCIELab...");
		ScielabProcessor scielabProcessor = new ScielabProcessor(dpi, viewingDistance, whitepoint, this, imageProcessor);
        perfTime = addPerfLabel(perfTime, "Init scielab");
        setStageName("SCIELab de l'image originale...");
		float[] scImg = scielabProcessor.sRGBToScielab(im.getDataXYCAsFloat(), im.getSizeX());
        perfTime = addPerfLabel(perfTime, "S-CIELab on the original image");
        setStageName("Optimisation...");
        float[] bestColors = scielabProcessor.bestColors(inlineRGBImage, scImg,im.getSizeX(),nbOfColors,swasa);
        perfTime = addPerfLabel(perfTime, "Optimisation de la quantification");
        float[] quantizedImage = imageProcessor.quantize(inlineRGBImage,bestColors);
        perfTime = addPerfLabel(perfTime, "Quantification de l'image");
        float[][] outImg = makeChannels(quantizedImage);

		Sequence seqOut = new Sequence();

		IcyBufferedImage imageOut =new IcyBufferedImage(im.getSizeX(), im.getSizeY(), im.getSizeC(), im.getDataType_());
		imageOut.beginUpdate();
		// Copie du tableau vers la sequence
		imageOut.setDataXY(0, Array1DUtil.floatArrayToArray(outImg[0], imageOut.getDataXY(0)));
		imageOut.setDataXY(1, Array1DUtil.floatArrayToArray(outImg[1], imageOut.getDataXY(1)));
		imageOut.setDataXY(2, Array1DUtil.floatArrayToArray(outImg[2], imageOut.getDataXY(2)));
		imageOut.endUpdate();
		imageOut = IcyBufferedImageUtil.convertToType(imageOut, DataType.UBYTE, true);

		seqOut.addImage(imageOut);
		seqOut.setName("Resultat("+(System.currentTimeMillis()-start)+"ms)");

		// Affichage
		addSequence(seqOut);
        perfTime = addPerfLabel(perfTime, "Affichage");
		scielabProcessor.close();
	}


	@Override
	protected void initialize() {

		super.setTimeDisplay(true);
		EzinputSeq = new EzVarSequence("Input");
		EzinputSeq.setToolTipText("Images to be processed");
		EznbOfColors = new EzVarInteger("Number of colors",8,1,16777216,1);
		EznbOfColors.setToolTipText("Target number of colors in the palette | Default : 8 | Range : [1, 2^24]");

		//General optimization parameters
		EzpopulationSize = new EzVarInteger("Population size", 4,1,Integer.MAX_VALUE,1);
		EzpopulationSize.setToolTipText("Number of color palettes used to find the optimized palette. Will linearly increase computation time| Default : 4");
		Ezimax = new EzVarInteger("Max iterations", 5000,1, Integer.MAX_VALUE,1);
		Ezimax.setToolTipText("Maximum number of iterations. Will linearly increase computation time| Default : 5000");
		Ezdelta = new EzVarFloat("Penalty Constant", 2, 0, Float.MAX_VALUE, 1);
		Ezdelta.setToolTipText("Penalty constant for unused palette colors. | Default : 2");

		EzConvDelay = new EzVarFloat("Convergence delay", 0.75f, 0.0f, 1.0f, 0.05f);
		EzConvDelay.setToolTipText("Convergence delay of the population | Default : 0.75 | Range [0,1]");
		EzConvSpread = new EzVarFloat("Convergence spread", 0.15f, 0.0f, 1.0f, 0.05f);
		EzConvSpread.setToolTipText("Convergence spread of the population | Default : 0.15 | Range [0,1]");

		//Temperature
		EzT0 = new EzVarFloat("Initial temperature", 20, 0, Float.MAX_VALUE, 1);
		EzT0.setToolTipText("Initial temperature used in the simulated annealing process. | Default : 20");
		EziTc = new EzVarInteger("Iterations per temperature",20, 1, Integer.MAX_VALUE, 1);
		EziTc.setToolTipText("Number of iterations where the temperature is kept constant (iterations per step). Default : 20");
		Ezalpha = new EzVarFloat("Cooling coefficient", 0.9f, 0.0f ,1.0f,0.1f);
		Ezalpha.setToolTipText("Cooling coefficient by which the temperature is changed per step. | Default : 0.9 | Range : [0,1]");
		EzGroup temperatureGroup = new EzGroup("Temperature",EzT0, EziTc, Ezalpha);
		EzGroup optimizationGroup = new EzGroup("Optimization",EzpopulationSize, Ezimax, Ezdelta,EzConvDelay, EzConvSpread, temperatureGroup);

		//Step size parameters
		Ezs0 = new EzVarFloat("Initial Step size", 100, 1, 256, 1);
		Ezbeta = new EzVarFloat("Adaptation constant", 5.3f, 0,Float.MAX_VALUE, 0.5f);
		EzGroup stepSizeGroup = new EzGroup("Step size", Ezs0, Ezbeta);

		//S-CIELAB Visual Settings
		EzLabel EzscielabWarning = new EzLabel("Keep these parameters to default for computing purposes. \nFor visual purposes, use your screen's specifications");
		Ezdpi = new EzVarInteger("Dpi", 72, 1, Integer.MAX_VALUE, 1);
		Ezdpi.setToolTipText("Screen dpi | Default : 72");
		EzViewingDistance = new EzVarFloat("Viewing distance", 45, 1, Float.MAX_VALUE, 1);
		EzViewingDistance.setToolTipText("Viewing distance from the screen in cm | Default : 45");
		EzWhitePoint = new EzVarEnum<>("White point", ScielabProcessor.Whitepoint.values(),ScielabProcessor.Whitepoint.D65);
		EzWhitePoint.setToolTipText("White point of the image | Default : D65");
		EzGroup scielabGroup = new EzGroup("S-CIELAB", EzscielabWarning, Ezdpi, EzViewingDistance, EzWhitePoint);

		super.addEzComponent(EzinputSeq);
		super.addEzComponent(EznbOfColors);
		super.addEzComponent(optimizationGroup);
		super.addEzComponent(stepSizeGroup);
		super.addEzComponent(scielabGroup);

		scielabGroup.setFoldedState(true);
	}

	public static long addPerfLabel(long start, String message)
    {
        System.out.println(message+ " : " + (System.currentTimeMillis()-start) + "ms");
        return System.currentTimeMillis();
    }

    public void updateProgressBar(String message, double progress)
	{
		super.getUI().setProgressBarMessage(message);
		super.getUI().setProgressBarValue(progress);
		Thread.yield();
	}

	public void setStageName(String name)
    {
        super.getStatus().setCompletion(Double.NaN);
        super.getStatus().setMessage(name);
        Thread.yield();
    }

	public float[] makeinline(float[][] image)
	{
		float[] inline = new float[image[0].length*4];
		for(int i=0;i<image[0].length;i++)
		{
			int offset = i<<2;
			inline[offset] = image[0][i];
			inline[offset+1] = image[1][i];
			inline[offset+2] = image[2][i];
			inline[offset+3] = 0.0f;
		}
		return inline;
	}

	public float[][] makeChannels(float[] inline)
	{
		float[][] channels = new float[3][];
		channels[0] = new float[inline.length/4];
		channels[1] = new float[inline.length/4];
		channels[2] = new float[inline.length/4];

		for(int i=0; i<channels[0].length; i++)
		{
			int offset = i << 2;
			channels[0][i] = inline[offset];
			channels[1][i] = inline[offset+1];
			channels[2][i] = inline[offset+2];
		}

		return channels;
	}

    @Override
    public void stopExecution() {
	    updateProgressBar("Stopping...", 1.0);
        stopFlag=true;
    }

    public boolean isStopFlag() {
        return stopFlag;
    }
}